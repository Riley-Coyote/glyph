<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    
    <title>Glyph Suite | Advanced Unicode Steganography Tools</title>
    
    <meta name="description" content="Unlock the power of Unicode steganography with Glyph Suite. Encode, decode, and analyze hidden messages with advanced tools. Perfect for stealth communication and digital privacy.">
    <meta name="keywords" content="Unicode, steganography, hidden messages, covert communication, character analysis, message encoding, privacy, security, glyph, glyph suite, unicode tools, text analysis, data hiding">
    <meta name="author" content="GlyphSuite.com">
    <meta name="robots" content="index, follow">
    
    <meta property="og:title" content="Glyph Suite | Advanced Unicode Steganography">
    <meta property="og:description" content="Encode, decode, and analyze hidden messages with Glyph Suite's advanced Unicode steganography tools. Explore the unseen layers of text.">
    <meta property="og:type" content="website">
    <meta property="og:url" content="https://www.glyphsuite.com"> <!-- Placeholder URL -->
    <meta property="og:image" content="/api/placeholder/1200/630">
    <meta property="og:image:alt" content="Glyph Suite Logo and Interface Preview">
    <meta property="og:site_name" content="Glyph Suite">
    
    <meta name="twitter:card" content="summary_large_image">
    <meta name="twitter:title" content="Glyph Suite | Advanced Unicode Steganography">
    <meta name="twitter:description" content="Encode, decode, and analyze hidden messages with Glyph Suite's advanced Unicode steganography tools.">
    <meta name="twitter:image" content="/api/placeholder/1200/630">
    
    <link rel="icon" href="/api/placeholder/32/32" sizes="any"> <!-- Placeholder favicon -->
    <link rel="apple-touch-icon" href="/api/placeholder/180/180">
    <!-- <link rel="manifest" href="/site.webmanifest"> --> <!-- Manifest would be a separate file -->
    
    <meta name="theme-color" content="#0A0A0F"> 
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
    <meta name="apple-mobile-web-app-title" content="Glyph Suite">
    <meta name="application-name" content="Glyph Suite">

    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.2.0/css/all.min.css">
    <style>
        /* Import IBM Plex Mono */
        @import url('https://fonts.googleapis.com/css2?family=IBM+Plex+Mono:wght@300;400;500;700&display=swap');
        
        @property --angle {
          syntax: '<angle>';
          initial-value: 0deg;
          inherits: false;
        }
        @property --shine-opacity {
          syntax: '<number>';
          initial-value: 0;
          inherits: false;
        }
        @property --shine-position {
          syntax: '<percentage>';
          initial-value: -100%;
          inherits: false;
        }


        :root {
            /* Core Colors */
            --main-bg: #0A0A0F; 
            --terminal-bg: rgba(10, 10, 14, 0.9); /* Darker, more terminal-like */
            --panel-bg: rgba(16, 16, 20, 0.85);    
            --card-bg: rgba(12, 12, 16, 0.9);      
            --border-color: #222228; /* Sharper border */
            --text-color: #a8b0b8; /* Cooler gray text, slightly dimmer for terminal */
            --active-color: #e8ecf0; 
            --dim-text: #4a5058;
            
            /* Highlight & Accent Colors */
            --highlight-color: #FFFFFF; 
            --secondary-highlight-color: #E0E0E0; 
            --logo-color: #221E30; 
            --logo-glow-color: rgba(88, 78, 116, 0.45); 

            /* Effects & States */
            --glow-color: rgba(255, 255, 255, 0.18); /* Reduced glow for sharper feel */
            --warm-light-color: rgba(255, 255, 255, 0.7); 
            
            --success-color: var(--active-color); 
            --success-border-color: #404850; 
            --success-bg-color: rgba(180, 200, 210, 0.07); 
            
            --error-color: #C0C8D0;   
            --error-border-color: #504850; 
            --error-bg-color: rgba(160,160,170,0.1); 
            
            --info-bg: rgba(200, 200, 220, 0.04); 
            --char-bg: #0e0e12; 
            --char-border: #222228;
            --found-bg: rgba(200, 200, 220, 0.05); 
            --found-border: var(--highlight-color); 

            /* Typography */
            --font-main: 'IBM Plex Mono', monospace; 
            --line-height-body: 1.7; /* Adjusted for smaller fonts */
            --line-height-heading: 1.35; /* Adjusted for smaller fonts */
            --letter-spacing-heading: 0.01em; /* Tighter for terminal feel */

            /* Spacing & Sizing */
            --spacing-unit: 6px; /* Reduced by ~25% from 8px */
            --radius-sm: 3px;  /* Sharper radius */
            --radius-md: 6px; 
            --radius-lg: 8px;

            /* Transitions & Animations */
            --transition-cubic: cubic-bezier(0.4, 0, 0.2, 1); 
            --transition-duration-fast: 0.15s; /* Faster for terminal feel */
            --transition-duration-normal: 0.25s;
            --transition-duration-slow: 0.4s;

            /* Reflective Edge Properties */
            --edge-highlight-color: rgba(255, 255, 255, 0.1); /* More subtle */
            --edge-shadow-color: rgba(0, 0, 0, 0.3);
            --edge-reflection-opacity: 0.6;
        }
        
        * { box-sizing: border-box; margin: 0; padding: 0; }
        html { scroll-behavior: smooth; }
        
        body {
            font-family: var(--font-main); 
            line-height: var(--line-height-body); background-color: var(--main-bg); color: var(--text-color);
            padding: 0; margin: 0;
            background-image: 
                radial-gradient(circle at 18px 18px, rgba(180, 180, 200, 0.01) 1px, transparent 1px), /* Scaled down dots */
                radial-gradient(circle at 52px 52px, rgba(100, 100, 120, 0.005) 1px, transparent 1px); 
            background-size: 70px 70px; /* Scaled down grid */ position: relative; min-height: 100vh; overflow-x: hidden;
        }
        
        body::before { 
            content: ""; position: fixed; top: 0; left: 0; width: 100%; height: 100%;
            background: radial-gradient(ellipse at center, 
                transparent 25%, 
                rgba(0,0,0,0.03) 38%, 
                rgba(0,0,0,0.07) 48%,
                rgba(0,0,0,0.12) 58%,
                rgba(0,0,0,0.18) 68%,
                rgba(0,0,0,0.25) 78%,
                rgba(0,0,0,0.35) 88%,
                rgba(0,0,0,0.45) 100%
            ); 
            pointer-events: none; z-index: -1;
        }
        
        .container { max-width: 1000px; margin: 0 auto; padding: calc(var(--spacing-unit) * 3.5); position: relative; } /* Reduced max-width */
        
        header {
            display: flex; align-items: center; justify-content: space-between;
            padding: calc(var(--spacing-unit) * 3.5) 0; border-bottom: 1px solid var(--border-color); margin-bottom: calc(var(--spacing-unit) * 5.5);
        }
        
        .logo { display: flex; align-items: center; }
        .logo h1 { font-family: var(--font-main); font-size: 1.47rem; font-weight: 700; color: var(--active-color); letter-spacing: 0.05em; text-shadow: 0 0 8px var(--glow-color); } /* Scaled font, adjusted letter-spacing & shadow */
        .logo-icon { margin-right: calc(var(--spacing-unit) * 2); font-size: 1.33rem; color: var(--logo-color); text-shadow: 0 0 8px var(--logo-glow-color); transition: transform var(--transition-duration-normal) var(--transition-cubic), text-shadow var(--transition-duration-normal) var(--transition-cubic); } /* Scaled font & shadow */
        .logo-icon:hover { transform: scale(1.12) rotate(-7deg); text-shadow: 0 0 14px var(--logo-glow-color), 0 0 5px var(--logo-color); }
        .tag-line { font-family: var(--font-main); font-size: 0.665rem; color: var(--dim-text); margin-left: calc(var(--spacing-unit) * 2.5); } /* Scaled font */
        
        h1, h2, h3 { font-family: var(--font-main); color: var(--active-color); font-weight: 500; line-height: var(--line-height-heading); letter-spacing: var(--letter-spacing-heading); }
        h2 { font-size: 1.12rem; margin-bottom: calc(var(--spacing-unit) * 3.5); display: flex; align-items: center; } /* Scaled font */
        h2 i { margin-right: calc(var(--spacing-unit) * 1.5); color: var(--highlight-color); transition: transform var(--transition-duration-fast) var(--transition-cubic); } 
        h2:hover i { transform: scale(1.1); }
        h3 { font-size: 0.875rem; margin-top: calc(var(--spacing-unit) * 4.5); margin-bottom: calc(var(--spacing-unit) * 2.75); display: flex; align-items: center; } /* Scaled font */
        h3 i { margin-right: calc(var(--spacing-unit) * 1.25); color: var(--active-color); }
        
        .header-main { text-align: center; margin-bottom: calc(var(--spacing-unit) * 7); }
        .header-main h1 { font-family: var(--font-main); font-size: 2.1rem; color: var(--active-color); margin-bottom: calc(var(--spacing-unit) * 2.5); letter-spacing: 0.01em; } /* Scaled font */
        .header-main p { font-family: var(--font-main); color: var(--text-color); font-size: 0.805rem; max-width: 560px; margin: 0 auto; line-height: 1.7; } /* Scaled font & max-width */
        
        .card-container { display: flex; flex-wrap: wrap; gap: calc(var(--spacing-unit) * 3.5); margin-top: calc(var(--spacing-unit) * 4.5); }
        .card {
            flex: 1; min-width: 220px; /* Adjusted for smaller content */ background-color: var(--card-bg);
            border: 1px solid var(--border-color); border-radius: var(--radius-md); padding: calc(var(--spacing-unit) * 4);
            box-shadow: 0 5px 18px rgba(0,0,0,0.3), 0 0 0 1px rgba(255,255,255,0.02) inset; 
            transition: transform var(--transition-duration-normal) var(--transition-cubic), 
                        box-shadow var(--transition-duration-normal) var(--transition-cubic), 
                        backdrop-filter var(--transition-duration-normal) var(--transition-cubic);
            position: relative; overflow: hidden;
            backdrop-filter: blur(3px); /* Reduced blur */
        }
        .card:hover { 
            transform: scale(1.015) translateY(-5px); /* Adjusted transform */
            box-shadow: 0 10px 30px rgba(0,0,0,0.38), 0 0 25px 7px rgba(255, 255, 255, 0.08), 0 0 12px rgba(255,255,255,0.06) inset; 
            backdrop-filter: blur(6px); /* Reduced hover blur */
        }
        .card h2 { font-family: var(--font-main); color: var(--active-color); margin-top: 0; font-size: 1.015rem; } /* Scaled font */
        .card-icon { margin-right: calc(var(--spacing-unit) * 2); font-size: 1.26rem; color: var(--highlight-color); } /* Scaled font */
        .card p { font-family: var(--font-main); margin: calc(var(--spacing-unit) * 2.5) 0; font-size: 0.686rem; } /* Scaled font */
        .card ul { margin: calc(var(--spacing-unit) * 2.5) 0; padding-left: calc(var(--spacing-unit) * 2.5); list-style-type: none; }
        .card ul li { font-family: var(--font-main); position: relative; padding-left: calc(var(--spacing-unit) * 2.5); margin-bottom: var(--spacing-unit); font-size: 0.686rem; } /* Added font size for li */
        .card ul li::before { content: "✓"; position: absolute; left: 0; color: var(--highlight-color); } 
        
        .btn { 
            display: inline-block; 
            background: linear-gradient(45deg, 
                var(--highlight-color) 0%, 
                var(--secondary-highlight-color) 30%, 
                var(--highlight-color) 50%, 
                var(--secondary-highlight-color) 70%, 
                var(--highlight-color) 100%);
            background-size: 250% 250%; 
            color: var(--main-bg); 
            text-decoration: none; padding: calc(var(--spacing-unit) * 1.225) calc(var(--spacing-unit) * 2.45); /* Scaled padding */
            border: 1px solid rgba(0, 0, 0, 0.1); /* Subtle dark border to define the shape on light bg */
            border-radius: var(--radius-md); margin-top: calc(var(--spacing-unit) * 3.5);
            transition: transform var(--transition-duration-fast) var(--transition-cubic),
                        box-shadow var(--transition-duration-normal) var(--transition-cubic), /* Slower for complex shadow */
                        background-position var(--transition-duration-slow) var(--transition-cubic),
                        border-color var(--transition-duration-fast) var(--transition-cubic);
            font-family: var(--font-main); font-weight: 600; 
            font-size: 0.665rem; display: inline-flex; align-items: center; cursor: pointer; /* Scaled font */
            box-shadow:
                /* Outer subtle white glow - for diffusion */
                0 0 6px rgba(255, 255, 255, 0.3),
                /* Inner bright white shine line - top/left emphasis for reflection */
                inset 0.5px 0.5px 1px var(--highlight-color),
                /* Subtle inner shadow for depth - bottom/right */
                inset -0.5px -0.5px 1px rgba(0, 0, 0, 0.15),
                /* Base drop shadow for the button itself */
                0 2px 5px rgba(0,0,0,0.2);
        }
        .btn:hover { 
            transform: translateY(-3px) scale(1.02); 
            background-position: 100% 50%; 
            border-color: rgba(0, 0, 0, 0.2); /* Slightly darker border on hover */
            box-shadow:
                /* Enhanced outer subtle white glow */
                0 0 12px rgba(255, 255, 255, 0.4), /* Diffusion */
                0 0 20px var(--glow-color), /* Main white glow */
                /* Enhanced Inner bright white shine line */
                inset 1px 1px 2px rgba(255, 255, 255, 0.9), /* Brighter, slightly larger shine */
                /* Enhanced Subtle inner shadow for depth */
                inset -1px -1px 2px rgba(0, 0, 0, 0.25),
                /* Enhanced drop shadow for the button itself */
                0 4px 12px rgba(0,0,0,0.3);
        }
        .btn i { margin-right: var(--spacing-unit); }

        .panel, .info-panel, .decoder-section { 
            background-color: var(--panel-bg); border: 1px solid var(--border-color);
            border-radius: var(--radius-md); padding: calc(var(--spacing-unit) * 3.5); margin-bottom: calc(var(--spacing-unit) * 4); /* Adjusted radius and padding */
            position: relative; overflow: hidden;
            backdrop-filter: blur(5px); /* Reduced blur */
            box-shadow: 0 1px 3px rgba(0,0,0,0.15), 0 0 0 1px rgba(255,255,255,0.015) inset; 
            transition: box-shadow var(--transition-duration-normal) var(--transition-cubic), backdrop-filter var(--transition-duration-normal) var(--transition-cubic);
        }
        .info-panel { background-color: var(--info-bg); border-left: 3px solid var(--highlight-color); } /* Thinner border */
        .decoder-section { background-color: var(--panel-bg); border-left: 3px solid var(--border-color); } /* Thinner border */

        .panel::before { 
            content: ''; position: absolute; top: 0; left: 0; right: 0; height: 1px;
            background: linear-gradient(90deg, 
                transparent 0%, 
                rgba(255,255,255,0.06) 20%, 
                var(--highlight-color) 50%, 
                rgba(255,255,255,0.06) 80%, 
                transparent 100%); 
            opacity: 0.4; 
        }
        
        .card::after, .panel::after, .info-panel::after, .decoder-section::after {
          content: ""; position: absolute; top: -1px; left: -1px; /* Adjusted for 1px border */
          width: calc(100% + 2px); height: calc(100% + 2px);
          border-radius: inherit; border: 1px solid transparent; /* Thinner trail border */
          border-image-slice: 1; opacity: 0;
          transition: opacity var(--transition-duration-normal) var(--transition-cubic); 
          pointer-events: none; z-index: 0; 
        }

        .card:hover::after, .panel:hover::after, .info-panel:hover::after, .decoder-section:hover::after {
          opacity: 1;
          border-image-source: conic-gradient(from var(--angle), 
            transparent 0%, 
            transparent 35%, 
            var(--warm-light-color) 48%, 
            var(--warm-light-color) 52%, 
            transparent 65%, 
            transparent 100%
          );
          animation: spinAngle 1.2s linear infinite; 
        }
        .panel:hover, .info-panel:hover, .decoder-section:hover {
            box-shadow: 0 7px 25px rgba(0,0,0,0.3), 0 0 20px rgba(255,255,255,0.04), 0 0 0 1px rgba(255,255,255,0.04) inset;
            backdrop-filter: blur(8px); /* Reduced hover blur */
        }


        @keyframes spinAngle { to { --angle: 360deg; } }
        
        textarea {
            width: 100%; min-height: 130px; /* Scaled */ padding: calc(var(--spacing-unit) * 1.8); margin-bottom: calc(var(--spacing-unit) * 2.5);
            font-family: var(--font-main); font-size: 0.665rem; /* Scaled */
            background-color: var(--terminal-bg); color: var(--active-color);
            border: 1px solid var(--border-color); border-radius: var(--radius-md); resize: vertical;
            caret-color: var(--highlight-color); 
            box-shadow: 0 1px 2px rgba(0,0,0,0.2) inset; 
            transition: box-shadow var(--transition-duration-fast) var(--transition-cubic), border-color var(--transition-duration-fast) var(--transition-cubic);
        }
        textarea:focus { 
            outline: none; border-color: var(--highlight-color); 
            box-shadow: 0 0 15px var(--glow-color), 0 0 0 2px rgba(255, 255, 255, 0.1), 0 1px 2px rgba(0,0,0,0.15) inset; /* Adjusted focus shadow */
        }
        
        button { 
            background-color: var(--terminal-bg); color: var(--active-color);
            border: 1px solid var(--border-color); border-radius: var(--radius-md); 
            padding: calc(var(--spacing-unit) * 1.05) calc(var(--spacing-unit) * 2.1); /* Scaled padding */ font-family: var(--font-main); font-weight: 500;
            font-size: 0.63rem; /* Scaled font */ cursor: pointer; margin-right: var(--spacing-unit); margin-bottom: calc(var(--spacing-unit) * 2);
            transition: background-color var(--transition-duration-fast) var(--transition-cubic), 
                        color var(--transition-duration-fast) var(--transition-cubic),
                        border-color var(--transition-duration-fast) var(--transition-cubic),
                        box-shadow var(--transition-duration-fast) var(--transition-cubic),
                        transform var(--transition-duration-fast) var(--transition-cubic);
            display: inline-flex; align-items: center;
            box-shadow: 0 1px 3px rgba(0,0,0,0.15), 0 0 0 1px rgba(255,255,255,0.02) inset; 
        }
        button:hover { 
            background-color: var(--highlight-color); color: var(--main-bg); 
            border-color: var(--highlight-color); 
            box-shadow: 0 0 15px var(--glow-color), 0 0 8px rgba(255,255,255,0.12) inset, 0 2px 6px rgba(0,0,0,0.25); 
        }
        button:active { transform: translateY(1px) scale(0.98); box-shadow: 0 0 7px var(--glow-color), 0 1px 1px rgba(0,0,0,0.3) inset; }
        button:disabled { opacity: 0.4; cursor: not-allowed; background-color: var(--terminal-bg); color: var(--dim-text); border-color: var(--border-color); box-shadow: none; }
        button:disabled:hover { box-shadow: none; background-color: var(--terminal-bg); color: var(--dim-text); } 
        button i { margin-right: var(--spacing-unit); }
        
        .result {
            background-color: var(--terminal-bg); color: var(--active-color);
            padding: calc(var(--spacing-unit) * 2.5); /* Scaled */ border: 1px solid var(--border-color); border-radius: var(--radius-md);
            margin-bottom: calc(var(--spacing-unit) * 3); /* Scaled */ font-family: var(--font-main); 
            white-space: pre-wrap; word-wrap: break-word; max-height: 280px; /* Scaled */
            overflow-y: auto; position: relative; line-height: var(--line-height-body);
            backdrop-filter: blur(2px); /* Reduced blur */
            box-shadow: 0 1px 2px rgba(0,0,0,0.25) inset; 
        }
        .result::before {
            content: "Output Stream"; position: absolute; top: calc(var(--spacing-unit) * -1.225); left: calc(var(--spacing-unit) * 2); /* Scaled */
            background-color: var(--terminal-bg); padding: calc(var(--spacing-unit) * 0.245) calc(var(--spacing-unit) * 0.875); font-size: 0.56rem; /* Scaled */
            font-family: var(--font-main); color: var(--dim-text); border-radius: var(--radius-sm); border: 1px solid var(--border-color);
        }
        
        .info-panel .terminal-line { font-family: var(--font-main); color: var(--active-color); }
        .info-panel .terminal-line::before { color: var(--highlight-color); content: ">"; } 
        
        .terminal-line { font-family: var(--font-main); position: relative; padding-left: calc(var(--spacing-unit) * 2.5); margin-bottom: calc(var(--spacing-unit) * 1.5); font-size: 0.63rem; } /* Scaled */
        .terminal-line::before { content: "$"; position: absolute; left: 0; color: var(--highlight-color); } 
        
        .char-info-container { line-height: 2.1; } /* Adjusted */
        .char-info-item {
            position: relative; display: inline-block; font-family: var(--font-main);
            padding: 0 1px; margin: 0; border-radius: var(--radius-sm); /* Tighter spacing */
            cursor: default;
        }
        .char-info-item.special {
            background-color: rgba(220, 220, 220, 0.08); /* Slightly less visible for smaller text */
            border: 1px solid var(--highlight-color); 
        }
        .char-info-item:hover .tooltip { display: block; opacity: 1; transform: translateX(-50%) translateY(-3px); } 
        .tooltip {
            display: none; opacity: 0; position: absolute; bottom: 130%; left: 50%; 
            transform: translateX(-50%) translateY(3px); padding: calc(var(--spacing-unit) * 0.8) calc(var(--spacing-unit) * 1.2); /* Scaled */
            background-color: var(--char-bg); color: var(--active-color);
            border-radius: var(--radius-sm); font-size: 0.56rem; /* Scaled */ white-space: nowrap;
            z-index: 10; border: 1px solid var(--border-color); font-family: var(--font-main);
            box-shadow: 0 3px 7px rgba(0,0,0,0.3);
            transition: opacity var(--transition-duration-fast) var(--transition-cubic), transform var(--transition-duration-fast) var(--transition-cubic);
        }
        .char-code {
            font-size: 0.525em; /* Scaled */ color: var(--dim-text); margin: 0 1px;
            background-color: var(--char-bg); padding: 1px 2px; border-radius: var(--radius-sm); font-family: var(--font-main);
        }
        .char-code .ascii-mapping { 
            color: var(--highlight-color); 
            font-style: italic;
        }
        
        .stats {
            margin: calc(var(--spacing-unit) * 2.5) 0; font-size: 0.63rem; /* Scaled */ color: var(--text-color); font-family: var(--font-main);
            background-color: var(--panel-bg); padding: calc(var(--spacing-unit) * 1.75) calc(var(--spacing-unit) * 2.1); /* Scaled */
            border-radius: var(--radius-sm); border-left: 2px solid var(--border-color); /* Thinner border */
            backdrop-filter: blur(2px); /* Reduced blur */
        }
        
        .method-info {
            display: none; margin-top: calc(var(--spacing-unit) * 2.5); padding: calc(var(--spacing-unit) * 2); /* Scaled */ font-family: var(--font-main);
            background-color: var(--info-bg); border-left: 2px solid var(--highlight-color); /* Thinner border */
            font-size: 0.63rem; /* Scaled */ border-radius: var(--radius-sm);
        }
        .method-info strong { color: var(--active-color); }
        .method-info code { background-color: var(--terminal-bg); border-color: var(--border-color); font-family: var(--font-main); }
        
        select {
            padding: calc(var(--spacing-unit) * 1.05) calc(var(--spacing-unit) * 1.4); /* Scaled */ border-radius: var(--radius-md); border: 1px solid var(--border-color); 
            background-color: var(--terminal-bg); color: var(--active-color);
            font-family: var(--font-main); margin: var(--spacing-unit) 0 calc(var(--spacing-unit) * 2.5) 0;
            width: 100%; max-width: 350px; /* Scaled */ font-size: 0.665rem; /* Scaled */ appearance: none; -webkit-appearance: none;
            background-image: url("data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' width='24' height='24' viewBox='0 0 24 24' fill='none' stroke='%23b0b0b0' stroke-width='2' stroke-linecap='round' stroke-linejoin='round'%3E%3Cpolyline points='6 9 12 15 18 9'%3E%3C/polyline%3E%3C/svg%3E"); 
            background-repeat: no-repeat; background-position: right calc(var(--spacing-unit) * 1.05) center; background-size: 13px; /* Scaled */
            transition: box-shadow var(--transition-duration-fast) var(--transition-cubic), border-color var(--transition-duration-fast) var(--transition-cubic);
            box-shadow: 0 1px 1px rgba(0,0,0,0.15) inset; 
        }
        select:focus { 
            outline: none; border-color: var(--highlight-color); 
            box-shadow: 0 0 15px var(--glow-color), 0 0 0 2px rgba(255, 255, 255, 0.1), 0 1px 2px rgba(0,0,0,0.1) inset; /* Adjusted focus */
        } 
        
        .tabs { display: flex; margin-bottom: calc(var(--spacing-unit) * 3); border-bottom: 1px solid var(--border-color); }
        .tab-btn {
            background-color: transparent; color: var(--text-color); font-family: var(--font-main);
            border: 1px solid transparent; border-bottom: none;
            padding: calc(var(--spacing-unit) * 1.05) calc(var(--spacing-unit) * 1.925); /* Scaled */ cursor: pointer; 
            transition: color var(--transition-duration-fast) var(--transition-cubic), background-color var(--transition-duration-fast) var(--transition-cubic), text-shadow var(--transition-duration-fast) var(--transition-cubic);
            margin-right: var(--spacing-unit); margin-bottom: -1px; border-radius: var(--radius-sm) var(--radius-sm) 0 0; font-size: 0.63rem; /* Scaled */
        }
        .tab-btn.active { background-color: var(--panel-bg); color: var(--highlight-color); border-color: var(--border-color); border-bottom-color: var(--panel-bg); } 
        .tab-btn:not(.active):hover { color: var(--active-color); background-color: rgba(255,255,255,0.02); text-shadow: 0 0 5px rgba(255,255,255,0.25); } 
        .tab-content { display: none; padding: calc(var(--spacing-unit) * 3) calc(var(--spacing-unit) * 0.5); }
        .tab-content.active { display: block; animation: fadeIn 0.5s var(--transition-cubic); }
        
        .step-number {
            display: inline-flex; align-items: center; justify-content: center;
            width: calc(var(--spacing-unit) * 2.8); height: calc(var(--spacing-unit) * 2.8); /* Scaled */ background-color: var(--terminal-bg);
            border: 1px solid var(--border-color); border-radius: 50%;
            margin-right: calc(var(--spacing-unit) * 1.5); font-size: 0.63rem; /* Scaled */ color: var(--active-color); font-weight: bold; font-family: var(--font-main);
        }
        
        .category-label {
            font-size: 0.56rem; /* Scaled */ color: var(--dim-text); margin-left: var(--spacing-unit); font-family: var(--font-main);
            background-color: var(--char-bg); padding: calc(var(--spacing-unit) * 0.25) calc(var(--spacing-unit) * 0.75); border-radius: var(--radius-sm);
        }
        
        .nav-links { margin-bottom: calc(var(--spacing-unit) * 3); }
        .nav-links a {
            margin-right: calc(var(--spacing-unit) * 2.5); color: var(--text-color); text-decoration: none; font-family: var(--font-main);
            font-size: 0.665rem; /* Scaled */ padding: var(--spacing-unit) calc(var(--spacing-unit) * 0.5); position: relative; cursor: pointer;
            transition: color var(--transition-duration-fast) var(--transition-cubic), text-shadow var(--transition-duration-normal) var(--transition-cubic); 
        }
        .nav-links a:hover { color: var(--active-color); text-shadow: 0 0 8px rgba(255,255,255,0.5); } 
        .nav-links a.active { color: var(--highlight-color); font-weight: bold; } 
        .nav-links a.active::after {
            content: ""; position: absolute; bottom: -2px; left: 0;
            width: 100%; height: 2px;
            animation: gradientMove 6s ease infinite;
            background-image: linear-gradient(45deg, 
                var(--highlight-color) 0%, 
                var(--secondary-highlight-color) 25%,
                var(--highlight-color) 50%, 
                var(--secondary-highlight-color) 75%,
                var(--highlight-color) 100%); 
            background-size: 200% 200%;
        }
        
        .feedback-message { padding: calc(var(--spacing-unit) * 1.25) calc(var(--spacing-unit) * 2); border-radius: var(--radius-sm); margin-top: calc(var(--spacing-unit) * 1.25); font-size: 0.63rem; /* Scaled */ display: flex; align-items: center; font-family: var(--font-main); }
        .feedback-message.success { color: var(--text-color); background-color: var(--success-bg-color); border-left: 3px solid var(--success-border-color); } /* Thinner border */
        .feedback-message.success i { color: var(--active-color); } 
        .feedback-message.error { color: var(--error-color); background-color: var(--error-bg-color); border-left: 3px solid var(--error-border-color); } /* Thinner border */
        .feedback-message.error i { color: var(--error-color); } 
         

        .message-found {
            margin-bottom: calc(var(--spacing-unit) * 2.5); padding: calc(var(--spacing-unit) * 2.25); background-color: var(--found-bg); 
            border-left: 2px solid var(--found-border); /* Thinner border */ border-radius: var(--radius-sm);
            backdrop-filter: blur(2px); /* Reduced blur */
        }
        .message-found .category { 
            color: var(--highlight-color); font-size: 0.595em; /* Scaled */ margin-bottom: calc(var(--spacing-unit) * 0.75); display: block; font-family: var(--font-main);
            background: linear-gradient(90deg, var(--highlight-color), var(--secondary-highlight-color)); 
            -webkit-background-clip: text; -webkit-text-fill-color: transparent;
            background-clip: text; text-fill-color: transparent;
        }
        .message-found pre {
            background-color: var(--main-bg); padding: calc(var(--spacing-unit) * 1.5); border-radius: var(--radius-sm); margin: calc(var(--spacing-unit) * 1.5) 0;
            overflow-x: auto; color: var(--active-color); border: 1px solid var(--border-color); font-family: var(--font-main); font-size: 0.63rem; /* Added font size */
        }
        
        .resources-list { list-style-type: none; padding-left: var(--spacing-unit); } 
        .resources-list li { margin-bottom: calc(var(--spacing-unit) * 1.5); position: relative; padding-left: calc(var(--spacing-unit) * 3.5); font-family: var(--font-main); font-size: 0.63rem; } /* Scaled */
        .resources-list li::before { content: "🔗"; position: absolute; left: 0; color: var(--highlight-color); font-size: 0.7rem; } /* Scaled */
        .resources-list li a { color: var(--text-color); text-decoration: none; transition: color var(--transition-duration-fast) var(--transition-cubic); }
        .resources-list li a:hover { color: var(--highlight-color); text-decoration: underline; }
        
        code { 
            background-color: var(--char-bg); padding: calc(var(--spacing-unit) * 0.25) calc(var(--spacing-unit) * 0.5); /* Scaled */ border-radius: var(--radius-sm);
            font-family: var(--font-main); color: var(--active-color);
            word-break: break-all; border: 1px solid var(--border-color); font-size: 0.6em; /* Relative to parent, which is smaller */
        }
        
        .footer {
            margin-top: calc(var(--spacing-unit) * 7.5); padding: calc(var(--spacing-unit) * 3.5) calc(var(--spacing-unit) * 2.5); /* Scaled */ border-top: 1px solid var(--border-color);
            color: var(--dim-text); font-size: 0.595rem; /* Scaled */ text-align: center; font-family: var(--font-main);
        }
        .footer p { margin: calc(var(--spacing-unit) * 0.5) 0; }
        .footer a { color: var(--text-color); text-decoration: none; }
        .footer a:hover { color: var(--highlight-color); text-decoration: underline; } 
        
        .decoder-section {
            margin-top: calc(var(--spacing-unit) * 4); padding: calc(var(--spacing-unit) * 2.5); 
            border-radius: var(--radius-md); 
        }
        .decoder-section p { font-family: var(--font-main); margin-bottom: calc(var(--spacing-unit) * 1.5); font-size: 0.63rem; } /* Scaled */
        .decoder-section ol, .decoder-section ul { padding-left: calc(var(--spacing-unit) * 3); margin-bottom: calc(var(--spacing-unit) * 1.5); }
        .decoder-section li { font-family: var(--font-main); margin-bottom: var(--spacing-unit); font-size: 0.63rem; } /* Scaled */
        .decoder-section strong { color: var(--active-color); }
        
        .ascii-canvas-container {
            position: fixed;
            top: 0; left: 0; width: 100%; height: 100%;
            pointer-events: none; 
            z-index: -2; 
            opacity: 0.09; /* Slightly more visible for dense terminal */
        }
        #asciiCanvas {
            display: block;
            width: 100%;
            height: 100%;
        }
        
        .section { display: none; }
        .section.active { display: block; animation: fadeIn 0.5s var(--transition-cubic); } 

        @keyframes fadeIn { from { opacity: 0; transform: translateY(8px); } to { opacity: 1; transform: translateY(0); } } /* Adjusted transformY */
        @keyframes gradientMove { 0% { background-position: 0% 50%; } 50% { background-position: 100% 50%; } 100% { background-position: 0% 50%; } }
        @keyframes blink { 0%, 100% { opacity: 1; } 50% { opacity: 0; } }
        
        .cursor::after {
            content: "_"; color: var(--highlight-color); 
            animation: blink 1s infinite; margin-left: 2px; /* Reduced margin */ font-weight: bold;
        }

        .delimiter-presets-container { display: flex; flex-wrap: wrap; gap: var(--spacing-unit); margin: calc(var(--spacing-unit) * 2) 0; }
        .delimiter-preset-btn {
            padding: calc(var(--spacing-unit) * 0.8) calc(var(--spacing-unit) * 1.2); /* Scaled */ background-color: var(--terminal-bg); color: var(--text-color);
            border: 1px solid var(--border-color); border-radius: var(--radius-sm); cursor: pointer;
            transition: border-color var(--transition-duration-fast) var(--transition-cubic), color var(--transition-duration-fast) var(--transition-cubic), background-color var(--transition-duration-fast) var(--transition-cubic); 
            font-size: 0.595rem; /* Scaled */ font-family: var(--font-main);
        }
        .delimiter-preset-btn:hover { border-color: var(--highlight-color); color: var(--active-color); } 
        .delimiter-preset-btn.selected {
            border-color: var(--highlight-color); background-color: var(--info-bg); 
            box-shadow: 0 0 7px var(--glow-color); color: var(--active-color); /* Scaled shadow */
        }
        .delimiter-preset-btn .name { font-weight: bold; }
        .delimiter-preset-btn .symbols { color: var(--highlight-color); margin-right: calc(var(--spacing-unit) * 0.75); } 

        .custom-delimiters-group { margin-top: calc(var(--spacing-unit) * 2); }
        .custom-delimiters-group input[type="text"] {
            padding: calc(var(--spacing-unit) * 1); /* Scaled */ background-color: var(--terminal-bg); color: var(--active-color);
            border: 1px solid var(--border-color); border-radius: var(--radius-sm); margin-right: var(--spacing-unit);
            font-family: var(--font-main); width: calc(50% - var(--spacing-unit)); font-size: 0.63rem; /* Added font-size */
            transition: box-shadow var(--transition-duration-fast) var(--transition-cubic), border-color var(--transition-duration-fast) var(--transition-cubic);
        }
        .custom-delimiters-group input[type="text"]:focus { 
            border-color: var(--highlight-color); 
            box-shadow: 0 0 12px var(--glow-color), 0 0 0 2px rgba(255, 255, 255, 0.1); /* Scaled shadow */
        } 
        
        ::-webkit-scrollbar { width: 8px; height: 8px; } /* Thinner scrollbar */
        ::-webkit-scrollbar-track { background: var(--terminal-bg); }
        ::-webkit-scrollbar-thumb { background: var(--border-color); border-radius: 3px; transition: background-color var(--transition-duration-fast) var(--transition-cubic); }
        ::-webkit-scrollbar-thumb:hover { background: var(--highlight-color); } 
        
        @media (max-width: 768px) {
            .container { padding: calc(var(--spacing-unit) * 2); }
            header { flex-direction: column; align-items: flex-start; gap: calc(var(--spacing-unit) * 2); }
            .logo h1 { font-size: 1.12rem; } .logo-icon { font-size: 0.98rem; } /* Scaled */
            .nav-links { display: flex; flex-wrap: wrap; gap: var(--spacing-unit); margin-bottom: calc(var(--spacing-unit) * 2.5); }
            .nav-links a { margin-right: var(--spacing-unit); font-size: 0.63rem; } /* Scaled */
            .card-container { gap: calc(var(--spacing-unit) * 2.5); } .card { min-width: 100%; padding: calc(var(--spacing-unit) * 2.5); }
            .panel, .info-panel, .decoder-section { padding: calc(var(--spacing-unit) * 2.5); }
            button, .btn { padding: calc(var(--spacing-unit) * 0.875) calc(var(--spacing-unit) * 1.575); font-size: 0.595rem; } /* Scaled */
            select { font-size: 0.595rem; } /* Scaled */
            .header-main h1 { font-size: 1.4rem; } .header-main p { font-size: 0.7rem; } /* Scaled */
            .custom-delimiters-group input[type="text"] { width: 100%; margin-bottom: var(--spacing-unit); }
        }
        @media (max-width: 480px) {
            .tag-line { display: none; }
            .tabs { flex-direction: column; }
            .tab-btn { margin-right: 0; margin-bottom: 2px; border-radius: var(--radius-sm); }
            .tab-btn.active { border-bottom-color: var(--border-color); }
        }
    </style>
</head>
<body>
    <!-- Canvas for ASCII Animations -->
    <div class="ascii-canvas-container">
        <canvas id="asciiCanvas"></canvas>
    </div>
    
    <div class="container">
        <header>
            <div class="logo">
                <span class="logo-icon"><i class="fas fa-ghost"></i></span>
                <h1>GLYPH SUITE</h1>
                <span class="tag-line" id="tagLine">// Official Unicode Toolkit</span>
            </div>
        </header>
        
        <nav class="nav-links">
            <a onclick="showSection('home-section')" id="homeLink" class="active">Home</a>
            <a onclick="showSection('analyzer-section')" id="analyzerLink">Analyzer</a>
            <a onclick="showSection('encoder-section')" id="encoderLink">Encoder</a>
        </nav>

        <section id="home-section" class="section active">
            <div class="info-panel">
                <div class="terminal-line">SYSTEM: Glyph Suite Kernel v4.2 (Film Grain Update) initialized.</div>
                <div class="terminal-line">PROTOCOL: Advanced Unicode Steganography (AUS-ECC) active.</div>
                <div class="terminal-line">RENDER_ENGINE: Analog Film Grain Simulator v1.0 online.</div>
                <div class="terminal-line">STATUS: <span class="cursor">Online & Ready</span></div>
            </div>
            <div class="header-main">
                <h1>Welcome to Glyph Suite</h1>
                <p>The essential toolkit for Unicode steganography. Encode, decode, and analyze hidden messages.</p>
            </div>
            <div class="card-container">
                <div class="card">
                    <h2><span class="card-icon"><i class="fas fa-search-plus"></i></span>Character Analyzer</h2>
                    <p>Dissect text to reveal hidden Unicode characters, invisible markers, and detailed code point information.</p>
                    <ul>
                        <li>Detect zero-width and non-rendering characters</li>
                        <li>Visualize character metadata and properties</li>
                        <li>Attempt extraction of concealed messages</li>
                    </ul>
                    <a class="btn" onclick="showSection('analyzer-section'); document.getElementById('analyzerLink').click();"><i class="fas fa-terminal"></i>Launch Analyzer</a>
                </div>
                <div class="card">
                    <h2><span class="card-icon"><i class="fas fa-key"></i></span>Message Encoder</h2>
                    <p>Embed secret messages within text using sophisticated Unicode steganography techniques.</p>
                    <ul>
                        <li>Multiple encoding vectors for varied applications</li>
                        <li>Generate completely invisible payloads</li>
                        <li>Craft deployment-ready steganographic text</li>
                    </ul>
                    <a class="btn" onclick="showSection('encoder-section'); document.getElementById('encoderLink').click();"><i class="fas fa-lock"></i>Launch Encoder</a>
                </div>
            </div>
            <div class="card-container" style="margin-top: 25px;">
                <div class="card" style="flex-basis: 100%;">
                    <h2><span class="card-icon"><i class="fas fa-info-circle"></i></span>About Unicode Steganography</h2>
                    <p>Unicode steganography is the art of concealing information within text by leveraging the vast and often underutilized characters within the Unicode standard. This technique primarily uses characters that are invisible, visually indistinguishable from others, or part of special-purpose blocks like Unicode Tags (U+E0000 to U+E007F).</p>
                    <p>Glyph Suite provides a comprehensive platform for both creating steganographic content and detecting its presence. All operations are performed client-side, ensuring your data never leaves your browser, guaranteeing maximum privacy and operational security.</p>
                </div>
            </div>
        </section>

        <section id="analyzer-section" class="section">
            <div class="info-panel">
                <div class="terminal-line">MODULE: Unicode Character Analyzer engaged.</div>
                <div class="terminal-line">SCAN MODE: Deep inspection (Tags, Surrogates, Special Chars).</div>
                <div class="terminal-line" id="analyzerStatus">STATUS: <span class="cursor">Awaiting Input</span></div>
            </div>
            <div class="panel">
                <h2><span class="step-number">01</span><i class="fas fa-file-import"></i>Input Text for Analysis</h2>
                <textarea id="analyzerInputText" placeholder="Paste or type text here to analyze for hidden Unicode characters..."></textarea>
                <button id="analyzeBtn"><i class="fas fa-search"></i>Analyze Text</button>
                <button id="loadSampleBtn"><i class="fas fa-vial"></i>Load Sample</button>
                <button id="clearAnalyzerBtn"><i class="fas fa-trash-alt"></i>Clear All</button>
            </div>
            <h2><i class="fas fa-microscope"></i>Character Stream Analysis</h2>
            <div id="analysisResult" class="result char-info-container">// Character-by-character breakdown will appear here.</div>
            <div id="statsResult" class="stats">// Analysis statistics will be shown here.</div>
            <h2><i class="fas fa-atom"></i>Detected Special Characters List</h2>
            <div id="charInfoList" class="result">// List of identified special Unicode characters.</div>
            <h2><i class="fas fa-key"></i>Message Operations</h2>
            <div class="tabs">
                <button class="tab-btn active" id="decodeTabBtn" onclick="switchAnalyzerTab('decodeTab')">Decode Message</button>
                <button class="tab-btn" id="encodeTabBtnQuick" onclick="switchAnalyzerTab('encodeTabQuick')">Quick Encode</button>
            </div>
            <div id="decodeTab" class="tab-content active">
                <h3><i class="fas fa-unlock-alt"></i>Extract Hidden Message</h3>
                <p>Attempt to decode hidden ASCII messages from the analyzed text using various steganographic vectors.</p>
                <button id="extractBtn"><i class="fas fa-magic"></i>Extract Message</button>
                <div id="decodedMessage" class="result">// Extracted message will appear here.</div>
            </div>
            <div id="encodeTabQuick" class="tab-content">
                <h3><i class="fas fa-pencil-alt"></i>Quick Encode Message</h3>
                <p>Enter a message to quickly encode using a selected Unicode steganography method:</p>
                <textarea id="messageToEncodeQuick" placeholder="Enter ASCII message to encode..."></textarea>
                <div>
                    <label for="encodingMethodQuick">Encoding Vector:</label>
                    <select id="encodingMethodQuick">
                        <option value="tag_chars">UNICODE_TAG [U+E0xxx Notation]</option>
                        <option value="surrogate_pairs_notation">SURROGATE_PAIR [Notation]</option>
                        <option value="actual_surrogates">PHANTOM_MODE [Invisible Surrogates]</option>
                        <option value="decorated">MARKED_PAYLOAD [Invisible + Delimiters]</option>
                    </select>
                </div>
                <div id="delimiterOptionsQuick" class="hidden">
                    <h4>Delimiter Options:</h4>
                    <div class="delimiter-presets-container" id="delimiterPresetsQuick"></div>
                    <label><input type="checkbox" id="customDelimitersCheckQuick"> Use custom delimiters</label>
                    <div id="customDelimitersQuick" class="custom-delimiters-group hidden">
                        <input type="text" id="openingDelimiterQuick" placeholder="Opening" maxlength="10">
                        <input type="text" id="closingDelimiterQuick" placeholder="Closing" maxlength="10">
                    </div>
                </div>
                <div style="margin-top: 15px;">
                    <button id="encodeBtnQuick"><i class="fas fa-bolt"></i>Encode Now</button>
                    <button id="copyEncodedBtnQuick" disabled><i class="fas fa-copy"></i>Copy Encoded</button>
                </div>
                <div id="encodedMessageQuick" class="result">// Quick encoded output will appear here.</div>
            </div>
            <div class="decoder-section">
                <h3><i class="fas fa-shield-alt"></i>Technical Deep Dive: Detection & Decoding</h3>
                <p>The Glyph Suite analyzer employs multiple strategies to detect and decode steganographic content:</p>
                <ol>
                    <li><strong>Direct Unicode Tag Characters:</strong> Identifies characters in the U+E0000 to U+E007F range and their `U+E0xxx` notation.</li>
                    <li><strong>UTF-16 Surrogate Pairs:</strong> Detects specific surrogate pairs (U+DB40 + U+DC00-U+DC7F) and their textual notations.</li>
                    <li><strong>Delimited Payloads:</strong> Recognizes messages encapsulated by known or custom delimiter patterns.</li>
                </ol>
                <p><strong>Decoding Process:</strong> Extracts steganographic characters/sequences, normalizes them (e.g., converts notation to actual characters), applies necessary offsets (0xE0000 or 0xDC00), and converts to ASCII.</p>
            </div>
            <h2><i class="fas fa-external-link-alt"></i>Further Unicode Resources</h2>
            <ul class="resources-list">
                <li><a href="https://www.branah.com/unicode-converter" target="_blank" rel="noopener noreferrer">Branah.com Unicode Converter</a></li>
                <li><a href="https://www.fileformat.info/info/unicode/char/search.htm" target="_blank" rel="noopener noreferrer">FileFormat.Info Unicode Character Search</a></li>
                <li><a href="https://unicode-table.com/" target="_blank" rel="noopener noreferrer">Unicode Character Table</a></li>
                <li><a href="https://home.unicode.org/" target="_blank" rel="noopener noreferrer">The Unicode Consortium</a></li>
            </ul>
        </section>

        <section id="encoder-section" class="section">
            <div class="info-panel">
                <div class="terminal-line">MODULE: Unicode Message Encoder activated.</div>
                <div class="terminal-line">MODE: High-Stealth Payload Generation.</div>
                <div class="terminal-line" id="encoderStatus">STATUS: <span class="cursor">Ready for Configuration</span></div>
            </div>
            <div class="panel">
                <h2><span class="step-number">01</span><i class="fas fa-keyboard"></i>Input Secret Payload (ASCII)</h2>
                <textarea id="messageToEncodeMain" placeholder="Enter your secret ASCII message here...">Hello world! This is a secret message hidden with Glyph Suite.</textarea>
            </div>
            <div class="panel">
                <h2><span class="step-number">02</span><i class="fas fa-cogs"></i>Select Encoding Vector</h2>
                <select id="encodingMethodMain" onchange="showMethodInfo()">
                    <option value="actual_surrogates">PHANTOM_MODE [Invisible Surrogates - Max Stealth]</option>
                    <option value="decorated">MARKED_PAYLOAD [Invisible + Delimiters - Recommended]</option>
                    <option value="tag_chars">UNICODE_TAG [U+E0xxx Notation - Visible Debug]</option>
                    <option value="surrogate_pairs_notation">SURROGATE_PAIR [Notation - Visible Debug]</option>
                </select>
                <div id="actualSurrogatesInfo" class="method-info">
                    <p><strong>PHANTOM_MODE [Invisible Surrogates]</strong></p>
                    <p>Encodes each ASCII character into an actual UTF-16 surrogate pair (e.g., U+DB40 U+DCxx). These pairs are typically rendered as invisible or zero-width characters.</p>
                    <p><strong>Stealth Level:</strong> Maximum. <strong>Use Case:</strong> Highest level of concealment.</p>
                </div>
                <div id="decoratedInfo" class="method-info">
                    <p><strong>MARKED_PAYLOAD [Invisible + Delimiters]</strong></p>
                    <p>Combines invisible surrogate pairs with visible start/end delimiters for robust extraction.</p>
                    <p><strong>Stealth Level:</strong> High. <strong>Use Case:</strong> Recommended for balance of stealth and robustness.</p>
                </div>
                <div id="tagCharsInfo" class="method-info">
                    <p><strong>UNICODE_TAG [U+E0xxx Notation]</strong></p>
                    <p>Encodes each ASCII character as a textual representation (e.g., \'A\' becomes "U+E0041"). Primarily for debugging.</p>
                    <p><strong>Stealth Level:</strong> Low. <strong>Use Case:</strong> Understanding mapping, testing.</p>
                </div>
                <div id="surrogatePairsInfo" class="method-info">
                    <p><strong>SURROGATE_PAIR [Notation]</strong></p>
                    <p>Represents ASCII characters using textual notation for UTF-16 surrogate pairs. Visible, for technical insight.</p>
                    <p><strong>Stealth Level:</strong> Low. <strong>Use Case:</strong> Demonstrating UTF-16 representation.</p>
                </div>
            </div>
             <div id="delimiterOptionsMain" class="panel hidden">
                <h2><span class="step-number">2A</span><i class="fas fa-palette"></i>Delimiter Options (for Marked Payload)</h2>
                <p>Choose from preset delimiter combinations or create your own:</p>
                <div class="delimiter-presets-container" id="delimiterPresetsMain"></div>
                <label style="display: block; margin-top: 15px;">
                    <input type="checkbox" id="customDelimitersCheckMain" style="margin-right: 5px;"> Use custom delimiters
                </label>
                <div id="customDelimitersMain" class="custom-delimiters-group hidden">
                    <input type="text" id="openingDelimiterMain" placeholder="Opening Delimiter (e.g., ⚗)" maxlength="10">
                    <input type="text" id="closingDelimiterMain" placeholder="Closing Delimiter (e.g., ⚗)" maxlength="10">
                </div>
            </div>
            <div class="panel">
                <h2><span class="step-number">03</span><i class="fas fa-magic"></i>Generate & Retrieve Encoded Message</h2>
                <button id="encodeBtnMain"><i class="fas fa-atom"></i>Encode Payload</button>
                <button id="copyEncodedBtnMain" disabled><i class="fas fa-copy"></i>Copy to Clipboard</button>
            </div>
            <h3><i class="fas fa-code"></i>Steganographic Output</h3>
            <div id="encodedMessageMain" class="result">// Your encoded message will appear here.</div>
        </section>

        <footer class="footer">
            <p>&copy; <span id="currentYear"></span> GlyphSuite.com. All rights reserved.</p>
            <p>Advanced Unicode Steganography Tools for Digital Privacy & Covert Communication.</p>
            <p><a href="#home-section" onclick="showSection('home-section'); document.getElementById('homeLink').click();">Home</a> | <a href="https://github.com/Riley-Coyote/glyph" target="_blank" rel="noopener noreferrer">GitHub</a></p>
        </footer>
    </div>
    
    <script>
        const specialCharacters = {
            '\u200B': { name: 'ZERO WIDTH SPACE', category: 'Invisible Separator' }, '\u200C': { name: 'ZERO WIDTH NON-JOINER', category: 'Invisible Separator' },
            '\u200D': { name: 'ZERO WIDTH JOINER', category: 'Invisible Separator' }, '\uFEFF': { name: 'ZERO WIDTH NO-BREAK SPACE (BOM)', category: 'Invisible Separator' },
            '\u00AD': { name: 'SOFT HYPHEN', category: 'Special Punctuation' }, '\u2060': { name: 'WORD JOINER', category: 'Special Punctuation' },
            '\u0009': { name: 'HORIZONTAL TAB', category: 'Whitespace' }, '\u000A': { name: 'LINE FEED', category: 'Whitespace' },
            '\u000D': { name: 'CARRIAGE RETURN', category: 'Whitespace' }, '\u0020': { name: 'SPACE', category: 'Whitespace' },
            '\u00A0': { name: 'NO-BREAK SPACE', category: 'Whitespace' }, '\u3000': { name: 'IDEOGRAPHIC SPACE', category: 'Whitespace' },
            '\u0000': { name: 'NULL', category: 'Control' }, '\u007F': { name: 'DELETE', category: 'Control' }
        };

        const delimiterPresets = [
            { name: "Alchemical Basic", opening: "⚗", closing: "⚗", description: "Alchemical apparatus" },
            { name: "Elements", opening: "🜄", closing: "🜁", description: "Air and Water symbols" },
            { name: "Atomic", opening: "⚛", closing: "⚛", description: "Atom symbol" },
            { name: "Quantum Wave", opening: "Ψ", closing: "Ψ", description: "Psi (Wave Function)" },
            { name: "Quantum Brackets", opening: "⟨", closing: "⟩", description: "Bra-Ket notation" },
            { name: "Alchemical Elements", opening: "🜃🜄", closing: "🜁🜂", description: "Fire/Air and Water/Earth" },
            { name: "Quantum Field", opening: "∮", closing: "∰", description: "Contour and Volume Integrals" },
            { name: "Planck-Tensor", opening: "ℏ", closing: "⊗", description: "Planck constant and Tensor product" },
            { name: "Planets", opening: "♅", closing: "♇", description: "Uranus and Pluto" },
            { name: "Uncertainty", opening: "Δ", closing: "∇", description: "Delta and Nabla" },
            { name: "Glyph Default", opening: "⊰•-✧-•⦑", closing: "⦒•-✧-•⊱", description: "Original Glyph Suite delimiters" }
        ];
        let selectedDelimiters = { 
            quick: { ...delimiterPresets[10] }, // Default to Glyph Default
            main: { ...delimiterPresets[10] }  // Default to Glyph Default
        };

        let currentSection = 'home-section'; 

        function showSection(sectionId) {
            document.querySelectorAll('.section').forEach(section => section.classList.remove('active'));
            document.getElementById(sectionId).classList.add('active');
            document.querySelectorAll('.nav-links a').forEach(link => link.classList.remove('active'));
            const activeNavLink = document.getElementById(sectionId.replace('-section', 'Link'));
            if (activeNavLink) activeNavLink.classList.add('active');
            
            currentSection = sectionId; 

            const tagLine = document.getElementById('tagLine');
            if (sectionId === 'home-section') tagLine.textContent = "// Official Unicode Toolkit v4.2";
            else if (sectionId === 'analyzer-section') tagLine.textContent = "// Analysis & Detection Module v4.2";
            else if (sectionId === 'encoder-section') tagLine.textContent = "// Payload Generation Engine v4.2";
        }
        
        const asciiCanvas = document.getElementById('asciiCanvas');
        const asciiCtx = asciiCanvas.getContext('2d');
        let asciiAnimationFrameId;
        let grains = [];
        const NUM_GRAINS = 3000; // Adjust for performance vs density
        const GRAIN_MAX_LIFE = 100; // Frames a grain "lives" before reset

        function initFilmGrain() {
            if (asciiAnimationFrameId) cancelAnimationFrame(asciiAnimationFrameId);
            asciiCanvas.width = window.innerWidth;
            asciiCanvas.height = window.innerHeight;
            grains = [];
            for (let i = 0; i < NUM_GRAINS; i++) {
                grains.push(createGrain());
            }
            drawFilmGrain();
        }

        function createGrain() {
            return {
                x: Math.random() * asciiCanvas.width,
                y: Math.random() * asciiCanvas.height,
                size: Math.random() * 1.5 + 0.5, // 0.5px to 2px
                opacity: Math.random() * 0.06 + 0.01, // 0.01 to 0.07 very subtle
                life: Math.floor(Math.random() * GRAIN_MAX_LIFE),
                vx: (Math.random() - 0.5) * 0.1, // Very subtle drift
                vy: (Math.random() - 0.5) * 0.1
            };
        }

        function drawFilmGrain() {
            // Clear with very low alpha for subtle trails, or clear fully for distinct grains
            asciiCtx.clearRect(0, 0, asciiCanvas.width, asciiCanvas.height); 
            // Or: asciiCtx.fillStyle = 'rgba(12, 12, 12, 0.1)'; asciiCtx.fillRect(0, 0, asciiCanvas.width, asciiCanvas.height);


            grains.forEach(grain => {
                grain.x += grain.vx;
                grain.y += grain.vy;
                grain.life++;

                if (grain.life > GRAIN_MAX_LIFE || grain.x < 0 || grain.x > asciiCanvas.width || grain.y < 0 || grain.y > asciiCanvas.height) {
                    // Reset grain
                    Object.assign(grain, createGrain(), { life: 0 }); // Keep some existing properties if needed, or fully recreate
                }
                
                // Vary opacity slightly over life for twinkling effect
                const lifeOpacityFactor = Math.sin((grain.life / GRAIN_MAX_LIFE) * Math.PI); // Fades in and out
                asciiCtx.fillStyle = `rgba(200, 200, 200, ${grain.opacity * lifeOpacityFactor})`;
                
                //fillRect is generally faster for many small items
                asciiCtx.fillRect(grain.x, grain.y, grain.size, grain.size);
            });

            asciiAnimationFrameId = requestAnimationFrame(drawFilmGrain);
        }
        
        window.addEventListener('resize', initFilmGrain);
        
        function analyzeText() {
            const text = document.getElementById('analyzerInputText').value;
            const resultDiv = document.getElementById('analysisResult');
            const statsDiv = document.getElementById('statsResult');
            const charInfoListDiv = document.getElementById('charInfoList');

            if (!text) {
                resultDiv.innerHTML = '<p>Please input text for analysis.</p>';
                statsDiv.innerHTML = ''; charInfoListDiv.innerHTML = ''; return;
            }
            
            let htmlResult = ''; let charCount = 0, specialCharCount = 0, whitespaceCount = 0, controlCharCount = 0;
            const foundSpecialCharsMap = new Map();
            
            for (let i = 0; i < text.length; i++) {
                const char = text.charAt(i); 
                const codePoint = text.codePointAt(i); 
                
                charCount++;
                let charDisplay = escapeHTML(char);
                let charClasses = 'char-info-item';
                let tooltipText = `Char: '${charDisplay}' Dec: ${codePoint} Hex: U+${codePoint.toString(16).toUpperCase().padStart(4, '0')}`;
                let asciiMapping = '';

                if (codePoint >= 0xE0000 && codePoint <= 0xE007F) { 
                    charClasses += ' special'; 
                    const mappedAscii = String.fromCharCode(codePoint - 0xE0000);
                    tooltipText = `Unicode Tag: U+${codePoint.toString(16).toUpperCase()} -> ASCII '${escapeHTML(mappedAscii)}' (${codePoint - 0xE0000})`;
                    asciiMapping = ` <span class="ascii-mapping">→ '${escapeHTML(mappedAscii)}'</span>`; 
                    if (!foundSpecialCharsMap.has(charDisplay)) foundSpecialCharsMap.set(charDisplay, { name: `Unicode Tag (${charDisplay})`, category: 'Steganographic Tag', code: `U+${codePoint.toString(16).toUpperCase()}`, count: 0, ascii: mappedAscii });
                    foundSpecialCharsMap.get(charDisplay).count++;
                    specialCharCount++;
                } else if (i + 1 < text.length && text.charCodeAt(i) === 0xDB40 && text.charCodeAt(i+1) >= 0xDC00 && text.charCodeAt(i+1) <= 0xDC7F) { 
                     charClasses += ' special'; 
                     const lowSurrogate = text.charCodeAt(i+1);
                     const mappedAscii = String.fromCharCode(lowSurrogate - 0xDC00);
                     charDisplay = escapeHTML(text.substring(i, i+2));
                     tooltipText = `Surrogate Tag Pair: U+DB40 U+${lowSurrogate.toString(16).toUpperCase()} -> ASCII '${escapeHTML(mappedAscii)}' (${lowSurrogate - 0xDC00})`;
                     asciiMapping = ` <span class="ascii-mapping">→ '${escapeHTML(mappedAscii)}'</span>`; 
                     if (!foundSpecialCharsMap.has(charDisplay)) foundSpecialCharsMap.set(charDisplay, { name: `Surrogate Tag Pair (${charDisplay})`, category: 'Steganographic Surrogate', code: `U+DB40 U+${lowSurrogate.toString(16).toUpperCase()}`, count: 0, ascii: mappedAscii });
                     foundSpecialCharsMap.get(charDisplay).count++;
                     specialCharCount++;
                     i++; 
                } else if (specialCharacters[char]) {
                    charClasses += ' special'; 
                    const info = specialCharacters[char];
                    tooltipText = `${info.name} (U+${codePoint.toString(16).toUpperCase()}) Category: ${info.category}`;
                    if (!foundSpecialCharsMap.has(charDisplay)) foundSpecialCharsMap.set(charDisplay, { ...info, code: `U+${codePoint.toString(16).toUpperCase()}`, count: 0 });
                    foundSpecialCharsMap.get(charDisplay).count++;
                    specialCharCount++;
                } else if (codePoint < 32 || codePoint === 127) {
                    controlCharCount++; charDisplay = `[CTRL:${codePoint.toString(16).toUpperCase().padStart(2,'0')}]`;
                    tooltipText = `Control Character (U+${codePoint.toString(16).toUpperCase()})`;
                } else if (/\s/.test(char)) {
                    whitespaceCount++;
                    if(char !== ' ') { charDisplay = `[WS:${codePoint.toString(16).toUpperCase().padStart(2,'0')}]`; tooltipText = `Whitespace (U+${codePoint.toString(16).toUpperCase()})`;}
                }
                
                htmlResult += `<span class="${charClasses}" title="${tooltipText}">${charDisplay}<span class="tooltip">${tooltipText}</span></span>`;
                htmlResult += `<span class="char-code">U+${codePoint.toString(16).toUpperCase().padStart(4, '0')}${asciiMapping}</span>`;
                if (codePoint > 0xFFFF && !(text.charCodeAt(i-1) === 0xDB40 && codePoint >= 0xDC00 && codePoint <= 0xDFFF && charClasses.includes('special'))) {
                }
            }
            
            statsDiv.innerHTML = `
                <div class="terminal-line">Total Characters: ${charCount}</div>
                <div class="terminal-line">Identified Special Chars: ${specialCharCount}</div>
                <div class="terminal-line">Control Characters: ${controlCharCount}</div>
                <div class="terminal-line">Whitespace Characters: ${whitespaceCount}</div>
                <div class="terminal-line">Analysis Status: Complete</div>`;
            
            resultDiv.innerHTML = htmlResult || '// No text analyzed.';
            
            let charInfoListHTML = '';
            if (foundSpecialCharsMap.size > 0) {
                charInfoListHTML = '<ul style="list-style-type: none; padding-left: 5px;">';
                foundSpecialCharsMap.forEach((info, displayChar) => {
                    charInfoListHTML += `
                        <li style="margin-bottom: 10px; position: relative; padding-left: 30px;">
                            <span style="position: absolute; left: 0; color:var(--highlight-color);">⦿</span>
                            <strong>${info.code}</strong> (${escapeHTML(displayChar)}): ${info.name} 
                            <span class="category-label">${info.category}</span> - Count: ${info.count}
                            ${info.ascii ? ` <span class="ascii-mapping">→ '${escapeHTML(info.ascii)}'</span>` : ''}
                        </li>`;
                });
                charInfoListHTML += '</ul>';
            } else {
                charInfoListHTML = '<div class="terminal-line">No specific special characters from the known list were detected.</div>';
            }
            charInfoListDiv.innerHTML = charInfoListHTML;
            updateAnalyzerStatus("Analysis complete. Ready for new input or message extraction.");
        }

        const decodingStrategies = [
            {
                name: "Direct Tag Character Decoder (U+E0xxx range & actual chars)",
                description: "Decodes actual Unicode tag characters (rendered invisibly) and their U+E0xxx notation.",
                decode: function(text) {
                    let message = '';
                    let count = 0;
                    for (let i = 0; i < text.length; i++) {
                        const codePoint = text.codePointAt(i);
                        if (codePoint >= 0xE0000 && codePoint <= 0xE007F) {
                            message += String.fromCharCode(codePoint - 0xE0000);
                            count++;
                            if (codePoint > 0xFFFF) i++; 
                        }
                    }
                    const tagNotationPattern = /U\+E00([0-7][0-9A-Fa-f])/gi;
                    let matchNotation;
                    while ((matchNotation = tagNotationPattern.exec(text)) !== null) {
                        const asciiCode = parseInt(matchNotation[1], 16);
                        if (asciiCode >=0 && asciiCode <= 0x7F) {
                             message += String.fromCharCode(asciiCode);
                             count++;
                        }
                    }
                    if (count > 0) {
                        return { found: true, message: message, details: `Decoded ${count} Unicode tag characters (actual & notation).` };
                    }
                    return { found: false };
                }
            },
            {
                name: "Surrogate Pair Decoder (Actual & Notation)",
                description: "Decodes tag characters represented by UTF-16 surrogate pairs (invisible) and their notation.",
                decode: function(text) {
                    let message = '';
                    let count = 0;
                    for (let i = 0; i < text.length - 1; i++) {
                        const highSurrogate = text.charCodeAt(i);
                        const lowSurrogate = text.charCodeAt(i + 1);
                        if (highSurrogate === 0xDB40 && (lowSurrogate >= 0xDC00 && lowSurrogate <= 0xDC7F)) {
                            message += String.fromCharCode(lowSurrogate - 0xDC00);
                            count++;
                            i++; 
                        }
                    }
                    const surrogateNotationPattern = /(?:56128\s*\|\s*U\+DB40|U\+DB40|\\uDB40)\s+(?:56[3-7][0-9]{2}|U\+DC([0-7][0-9A-Fa-f])|\\uDC([0-7][0-9A-Fa-f]))/gi;
                    let matchNotation;
                    while ((matchNotation = surrogateNotationPattern.exec(text)) !== null) {
                        const hexValue = matchNotation[1] || matchNotation[2]; 
                        if (hexValue) {
                            const asciiCode = parseInt(hexValue, 16);
                             if (asciiCode >=0 && asciiCode <= 0x7F) {
                                message += String.fromCharCode(asciiCode);
                                count++;
                            }
                        }
                    }
                    // Decode from all known/custom delimiters
                    const allDelimitersToTry = [...delimiterPresets];
                    const customCheckQuick = document.getElementById('customDelimitersCheckQuick');
                    if (customCheckQuick && customCheckQuick.checked) {
                        allDelimitersToTry.push({
                            name: "Custom (Analyzer)",
                            opening: document.getElementById('openingDelimiterQuick').value,
                            closing: document.getElementById('closingDelimiterQuick').value
                        });
                    }
                    const customCheckMain = document.getElementById('customDelimitersCheckMain');
                    if (customCheckMain && customCheckMain.checked) {
                        allDelimitersToTry.push({
                            name: "Custom (Encoder)",
                            opening: document.getElementById('openingDelimiterMain').value,
                            closing: document.getElementById('closingDelimiterMain').value
                        });
                    }
                    allDelimitersToTry.forEach(del => {
                        if (del.opening && del.closing && del.opening.length > 0 && del.closing.length > 0) {
                            try {
                                const regex = new RegExp(escapeRegex(del.opening) + "([\\s\\S]*?)" + escapeRegex(del.closing), "g");
                                let decoratedMatch;
                                while((decoratedMatch = regex.exec(text)) !== null) {
                                    const innerContent = decoratedMatch[1];
                                    for (let k = 0; k < innerContent.length - 1; k++) {
                                        const high = innerContent.charCodeAt(k); const low = innerContent.charCodeAt(k + 1);
                                        if (high === 0xDB40 && low >= 0xDC00 && low <= 0xDC7F) {
                                            message += String.fromCharCode(low - 0xDC00);
                                            count++;
                                            k++;
                                        }
                                    }
                                }
                            } catch (e) { console.warn("Regex error for delimiter:", del, e); }
                        }
                    });


                    if (count > 0) {
                        return { found: true, message: message, details: `Decoded ${count} characters from surrogate pairs (actual, notation, or decorated).` };
                    }
                    return { found: false };
                }
            },
            {
                name: "ASCII from Character Codes",
                description: "Extracts ASCII text from numerical codes if patterns suggest intentional encoding.",
                decode: function(text) {
                    const potentialCodes = [];
                    const codePattern = /(?<!U\+|0x|U\+DB40\s+56[3-7][0-9]{2}\|\s*U\+DC|56128\|\s*U\+DB40\s+\d+\|\s*U\+DC)\b([0-9]{2,3})\b/g;
                    let match;

                    while ((match = codePattern.exec(text)) !== null) {
                        const precedingText = text.substring(Math.max(0, match.index - 7), match.index);
                        if (/U\+[0-9A-F]{0,2}$/i.test(precedingText) || /char-code">U\+[0-9A-F]{0,2}$/i.test(precedingText) || /\d+\|U\+[0-9A-F]{0,2}$/i.test(precedingText) ) {
                            continue; 
                        }

                        const code = parseInt(match[1]);
                        if (code >= 32 && code <= 126) { 
                            potentialCodes.push({ code: code, char: String.fromCharCode(code), position: match.index });
                        }
                    }

                    if (potentialCodes.length === 0) { 
                        return { found: false, details: `No potential numerical ASCII codes found.` };
                    }

                    potentialCodes.sort((a, b) => a.position - b.position);
                    const decodedString = potentialCodes.map(c => c.char).join('');
                    
                    // No more filtering, return whatever is found
                    return {
                        found: true,
                        message: decodedString,
                        details: `Decoded ${decodedString.length} characters from ${potentialCodes.length} numerical ASCII codes (showing all found).`
                    };
                }
            }
            // Future: Add more strategies here (Binary, Morse, Base64, ROT13 etc.)
        ];
        
        function extractMessages() { 
            const text = document.getElementById('analyzerInputText').value; // Use original input for decoding
            const decodedMessageDiv = document.getElementById('decodedMessage');
            
            if (!text) {
                decodedMessageDiv.innerHTML = '<div class="terminal-line">ERROR: No text provided in input area for decoding.</div>';
                updateAnalyzerStatus("Extraction failed: No input text.", "error");
                return;
            }
            updateAnalyzerStatus("Extracting messages...", "info");
            
            let foundMessagesHTML = '';
            let messagesFoundCount = 0;
            
            decodingStrategies.forEach(strategy => {
                try {
                    const result = strategy.decode(text); // Pass original input text
                    if (result.found && result.message && result.message.length > 0) {
                        messagesFoundCount++;
                        foundMessagesHTML += `
                            <div class="message-found">
                                <p><strong>Strategy: ${escapeHTML(strategy.name)}</strong></p>
                                <pre>${escapeHTML(result.message)}</pre>
                                <p><small>${escapeHTML(result.details)}</small></p>
                            </div>`;
                    } else if (result.details && !result.found) { // Log why a strategy might have been skipped
                         foundMessagesHTML += `
                            <div class="message-found" style="border-left-color: var(--dim-text); background-color: rgba(100,100,100,0.05);">
                                <p><strong style="color:var(--dim-text);">${escapeHTML(strategy.name)}:</strong> <small>${escapeHTML(result.details)}</small></p>
                            </div>`;
                    }
                } catch (e) {
                    console.error("Decoding error with strategy", strategy.name, e);
                     foundMessagesHTML += `
                            <div class="message-found" style="border-left-color: var(--error-border-color);">
                                <p><strong>Strategy: ${escapeHTML(strategy.name)}</strong></p>
                                <p><small style="color:var(--error-color);">Error during decoding: ${escapeHTML(e.message)}</small></p>
                            </div>`;
                }
            });
            
            if (messagesFoundCount > 0) {
                decodedMessageDiv.innerHTML = `<h3><i class="fas fa-archive"></i> Extracted Content (${messagesFoundCount} result(s))</h3>${foundMessagesHTML}`;
            } else {
                decodedMessageDiv.innerHTML = `<div class="terminal-line">SCAN COMPLETE: No decodable hidden messages detected using current strategies.</div>${foundMessagesHTML}`; // Show skip reasons even if no message found
            }
            updateAnalyzerStatus(messagesFoundCount > 0 ? `Extraction complete: ${messagesFoundCount} potential message(s) found.` : "Extraction complete: No hidden messages found.", messagesFoundCount > 0 ? "success" : "info");
        }
        
        function clearAnalyzer() {
            document.getElementById('analyzerInputText').value = '';
            document.getElementById('analysisResult').innerHTML = '// Character-by-character breakdown will appear here.';
            document.getElementById('statsResult').innerHTML = '// Analysis statistics will be shown here.';
            document.getElementById('charInfoList').innerHTML = '// List of identified special Unicode characters.';
            document.getElementById('decodedMessage').innerHTML = '// Extracted message will appear here.';
            document.getElementById('messageToEncodeQuick').value = '';
            document.getElementById('encodedMessageQuick').innerHTML = '// Quick encoded output will appear here.';
            document.getElementById('copyEncodedBtnQuick').disabled = true;
            updateAnalyzerStatus("Analyzer cleared. Ready for new input.");
        }
        
        function escapeHTML(str) {
            if (typeof str !== 'string') return '';
            return str.replace(/&/g, '&amp;').replace(/</g, '&lt;').replace(/>/g, '&gt;').replace(/"/g, '&quot;').replace(/'/g, '&#39;');
        }
        function escapeRegex(string) { return string.replace(/[.*+?^${}()|[\]\\]/g, '\\$&'); }

        function performEncoding(message, method) {
            let openDel, closeDel;
            const sourcePrefix = currentSection === 'analyzer-section' ? 'Quick' : 'Main';
            
            if (method === 'decorated') {
                const customCheck = document.getElementById(`customDelimitersCheck${sourcePrefix}`);
                if (customCheck && customCheck.checked) {
                    openDel = document.getElementById(`openingDelimiter${sourcePrefix}`).value;
                    closeDel = document.getElementById(`closingDelimiter${sourcePrefix}`).value;
                } else { 
                    const delStore = sourcePrefix === 'Quick' ? selectedDelimiters.quick : selectedDelimiters.main;
                    openDel = delStore.opening;
                    closeDel = delStore.closing;
                }
            }
            
            switch (method) {
                case 'tag_chars': return encodeWithTagChars(message);
                case 'surrogate_pairs_notation': return encodeWithSurrogatePairNotation(message);
                case 'actual_surrogates': return encodeWithActualSurrogates(message);
                case 'decorated': return encodeWithDecoration(message, openDel, closeDel);
                default: return "Error: Unknown encoding method.";
            }
        }

        function encodeMessageQuick() {
            const message = document.getElementById('messageToEncodeQuick').value;
            const encodingMethod = document.getElementById('encodingMethodQuick').value;
            const encodedMessageDiv = document.getElementById('encodedMessageQuick');
            const copyBtn = document.getElementById('copyEncodedBtnQuick');
            if (!message) {
                encodedMessageDiv.innerHTML = '<div class="terminal-line" style="color:var(--error-color);">ERROR: No payload for Quick Encode.</div>';
                copyBtn.disabled = true; return;
            }
            const encodedText = performEncoding(message, encodingMethod);
            encodedMessageDiv.innerHTML = `<div class="terminal-line" style="color:var(--success-color);">ENCODING COMPLETE [${getEncodingMethodDescription(encodingMethod)}]</div>
                                          <pre style="margin-top: 10px;">${escapeHTML(encodedText)}</pre>`;
            copyBtn.disabled = false;
            updateAnalyzerStatus("Quick Encode complete.", "success");
        }

        function encodeMessageMain() {
            const message = document.getElementById('messageToEncodeMain').value;
            const encodingMethod = document.getElementById('encodingMethodMain').value;
            const encodedMessageDiv = document.getElementById('encodedMessageMain');
            const copyBtn = document.getElementById('copyEncodedBtnMain');
            if (!message) {
                encodedMessageDiv.textContent = 'ERROR: No payload. Enter message to encode.';
                copyBtn.disabled = true; 
                updateEncoderStatus("Encoding failed: No payload.", "error"); return;
            }
            const encodedText = performEncoding(message, encodingMethod);
            encodedMessageDiv.textContent = encodedText;
            copyBtn.disabled = false;
            updateEncoderStatus(`Encoding complete using ${getEncodingMethodDescription(encodingMethod)}. Output ready.`, "success");
        }
        
        function encodeWithTagChars(message) { 
            return Array.from(message).map((char, i) => {
                const code = char.charCodeAt(0);
                return code < 128 ? `U+E00${code.toString(16).padStart(2, '0').toUpperCase()}` + (((i + 1) % 8 === 0 && i < message.length -1) ? '\\n' : ' ') : char;
            }).join('').trim();
        }
        function encodeWithSurrogatePairNotation(message) { 
            return Array.from(message).map((char, i) => {
                const code = char.charCodeAt(0);
                if (code < 128) {
                    const lowSurrogateHex = code.toString(16).padStart(2, '0').toUpperCase();
                    return `U+DB40 U+DC${lowSurrogateHex}` + (((i + 1) % 3 === 0 && i < message.length -1) ? '\\n' : ' ');
                }
                return char + ' ';
            }).join('').trim();
        }
        function encodeWithActualSurrogates(message) { 
            return Array.from(message).map(char => {
                const code = char.charCodeAt(0);
                return code < 128 ? String.fromCharCode(0xDB40, 0xDC00 + code) : char;
            }).join('');
        }
        function encodeWithDecoration(message, opening, closing) {
            const surrogateEncoded = encodeWithActualSurrogates(message);
            return `${opening}${surrogateEncoded}${closing}`;
        }
        
        function copyToClipboard(elementId, isOutputInPre = false) {
            const targetElement = document.getElementById(elementId);
            let textToCopy = '';
            let feedbackAnchor = targetElement.closest('.panel') || targetElement.parentNode; 

            if (isOutputInPre && targetElement && targetElement.querySelector('pre')) {
                textToCopy = targetElement.querySelector('pre').textContent;
            } else if (targetElement) {
                textToCopy = targetElement.textContent;
                 if (targetElement.tagName === 'TEXTAREA') textToCopy = targetElement.value;
            }

            if (!textToCopy || textToCopy.startsWith('ERROR:') || textToCopy.includes("will appear here")) {
                showTemporaryMessage(feedbackAnchor, targetElement, 'Nothing valid to copy.', 'error'); return;
            }
            navigator.clipboard.writeText(textToCopy).then(() => {
                showTemporaryMessage(feedbackAnchor, targetElement, 'Payload copied to clipboard!', 'success');
            }).catch(err => {
                console.error('Failed to copy: ', err);
                showTemporaryMessage(feedbackAnchor, targetElement, 'Failed to copy. Check console.', 'error');
            });
        }

        function showTemporaryMessage(anchorElement, referenceElement, message, type = 'success') {
            const messageDiv = document.createElement('div');
            messageDiv.className = `feedback-message ${type}`;
            let iconClass = type === 'success' ? 'fa-check-circle' : 'fa-times-circle';
            let iconColor = type === 'success' ? 'var(--active-color)' : 'var(--error-color)'; 
            messageDiv.innerHTML = `<i class="fas ${iconClass}" style="color:${iconColor};"></i> ${escapeHTML(message)}`;
            anchorElement.insertBefore(messageDiv, referenceElement.nextSibling);
            setTimeout(() => messageDiv.remove(), 3000);
        }
        
        function getEncodingMethodDescription(method) {
            const descriptions = {
                'tag_chars': 'UNICODE_TAG Notation', 'surrogate_pairs_notation': 'SURROGATE_PAIR Notation',
                'actual_surrogates': 'PHANTOM_MODE (Invisible)', 'decorated': 'MARKED_PAYLOAD (Delimited)'
            };
            return descriptions[method] || method;
        }
        
        function switchAnalyzerTab(tabId) {
            document.querySelectorAll('#analyzer-section .tab-content').forEach(tab => tab.classList.remove('active'));
            document.querySelectorAll('#analyzer-section .tab-btn').forEach(button => button.classList.remove('active'));
            document.getElementById(tabId).classList.add('active');
            document.getElementById(tabId === 'encodeTabQuick' ? 'encodeTabBtnQuick' : 'decodeTabBtn').classList.add('active');
        }
        
        function showMethodInfo() { 
            const method = document.getElementById('encodingMethodMain').value;
            document.querySelectorAll('#encoder-section .method-info').forEach(div => div.style.display = 'none');
            const delimiterOptionsDiv = document.getElementById('delimiterOptionsMain');
            
            const infoDivId = {
                'tag_chars': 'tagCharsInfo', 'surrogate_pairs_notation': 'surrogatePairsInfo',
                'actual_surrogates': 'actualSurrogatesInfo', 'decorated': 'decoratedInfo'
            }[method];
            
            if (infoDivId && document.getElementById(infoDivId)) document.getElementById(infoDivId).style.display = 'block';
            if (delimiterOptionsDiv) delimiterOptionsDiv.classList.toggle('hidden', method !== 'decorated');
        }

        function loadSampleText() {
            const sample = `This is a sample​ text with\\u200B zero-width\\u200C spaces\\u200D and\\u00A0non-breaking\\u2002spaces.\\nIt also includes some\\ttabs and\\rcarriage returns.\\nExample 1 (Tag Notation): U+E0048 U+E0065 U+E006C U+E006C U+E006F\\nExample 2 (Invisible Surrogates): ⊰•-✧-•⦑󠁈󠁥󠁬󠁬󠁯󠀠󠁗󠁯󠁲󠁬󠁤󠀡⦒•-✧-•⊱\\nExample 3 (Surrogate Notation): U+DB40 U+DC48 U+DB40 U+DC65 U+DB40 U+DC6C`; 
            document.getElementById('analyzerInputText').value = sample;
            updateAnalyzerStatus("Sample text loaded. Ready for analysis.");
        }

        function updateAnalyzerStatus(message, type = "info") {
            const statusEl = document.getElementById('analyzerStatus');
            let colorVar = 'var(--text-color)';
            if (type === 'success') colorVar = 'var(--success-color)'; 
            else if (type === 'error') colorVar = 'var(--error-color)';
            statusEl.innerHTML = `STATUS: <span style="color:${colorVar};">${escapeHTML(message)}</span> <span class="cursor"></span>`;
        }
        function updateEncoderStatus(message, type = "info") {
            const statusEl = document.getElementById('encoderStatus');
            let colorVar = 'var(--text-color)';
            if (type === 'success') colorVar = 'var(--success-color)'; 
            else if (type === 'error') colorVar = 'var(--error-color)';
            statusEl.innerHTML = `STATUS: <span style="color:${colorVar};">${escapeHTML(message)}</span> <span class="cursor"></span>`;
        }

        function setupDelimiterOptions(containerId, checkId, customGroupId, openId, closeId, typeSuffix) {
            const container = document.getElementById(containerId);
            if (!container) return;
            container.innerHTML = ''; 
            delimiterPresets.forEach((preset) => {
                const btn = document.createElement('button');
                btn.className = 'delimiter-preset-btn';
                btn.innerHTML = `<span class="symbols">${preset.opening}...${preset.closing}</span> <span class="name">${preset.name}</span>`;
                btn.onclick = () => {
                    document.getElementById(checkId).checked = false;
                    document.getElementById(customGroupId).classList.add('hidden');
                    document.querySelectorAll(`#${containerId} .delimiter-preset-btn`).forEach(b => b.classList.remove('selected'));
                    btn.classList.add('selected');
                    selectedDelimiters[typeSuffix] = preset;
                };
                if (JSON.stringify(selectedDelimiters[typeSuffix]) === JSON.stringify(preset) && !document.getElementById(checkId).checked) {
                    btn.classList.add('selected');
                }
                container.appendChild(btn);
            });

            const customCheckElement = document.getElementById(checkId);
            customCheckElement.onchange = function() {
                document.getElementById(customGroupId).classList.toggle('hidden', !this.checked);
                if (this.checked) {
                    document.querySelectorAll(`#${containerId} .delimiter-preset-btn`).forEach(b => b.classList.remove('selected'));
                    selectedDelimiters[typeSuffix] = { 
                        opening: document.getElementById(openId).value,
                        closing: document.getElementById(closeId).value
                    };
                } else { 
                    const firstPresetBtn = container.querySelector('.delimiter-preset-btn');
                    if (firstPresetBtn) firstPresetBtn.click(); else selectedDelimiters[typeSuffix] = delimiterPresets[10]; // Fallback to Glyph Default
                }
            };
            document.getElementById(customGroupId).classList.toggle('hidden', !customCheckElement.checked);

            const openInput = document.getElementById(openId);
            const closeInput = document.getElementById(closeId);
            if (openInput && !openInput.value) openInput.value = delimiterPresets[10].opening; // Glyph Default
            if (closeInput && !closeInput.value) closeInput.value = delimiterPresets[10].closing; // Glyph Default
            
            openInput.oninput = () => { if(customCheckElement.checked) selectedDelimiters[typeSuffix].opening = openInput.value; };
            closeInput.oninput = () => { if(customCheckElement.checked) selectedDelimiters[typeSuffix].closing = closeInput.value; };
        }
        
        document.addEventListener('DOMContentLoaded', function() {
            initFilmGrain(); // Initialize new Film Grain animation
            showSection('home-section'); 
            
            document.getElementById('analyzerInputText').value = ''; 
            document.getElementById('messageToEncodeMain').value = 'Hello world! This is a secret message hidden with Glyph Suite.';

            document.getElementById('analyzeBtn').addEventListener('click', analyzeText);
            document.getElementById('loadSampleBtn').addEventListener('click', loadSampleText);
            document.getElementById('clearAnalyzerBtn').addEventListener('click', clearAnalyzer);
            document.getElementById('extractBtn').addEventListener('click', extractMessages);
            document.getElementById('encodeBtnQuick').addEventListener('click', encodeMessageQuick);
            document.getElementById('copyEncodedBtnQuick').addEventListener('click', () => copyToClipboard('encodedMessageQuick', true));
            
            const encodingMethodQuickSelect = document.getElementById('encodingMethodQuick');
            encodingMethodQuickSelect.onchange = () => {
                document.getElementById('delimiterOptionsQuick').classList.toggle('hidden', encodingMethodQuickSelect.value !== 'decorated');
            };
            setupDelimiterOptions('delimiterPresetsQuick', 'customDelimitersCheckQuick', 'customDelimitersQuick', 'openingDelimiterQuick', 'closingDelimiterQuick', 'quick');
            document.getElementById('delimiterOptionsQuick').classList.add('hidden');

            document.getElementById('encodeBtnMain').addEventListener('click', encodeMessageMain);
            document.getElementById('copyEncodedBtnMain').addEventListener('click', () => copyToClipboard('encodedMessageMain'));
            document.getElementById('encodingMethodMain').onchange = showMethodInfo; 
            setupDelimiterOptions('delimiterPresetsMain', 'customDelimitersCheckMain', 'customDelimitersMain', 'openingDelimiterMain', 'closingDelimiterMain', 'main');
            
            showMethodInfo(); 
            encodeMessageMain(); 
            document.getElementById('currentYear').textContent = new Date().getFullYear();
        });
    </script>
</body>
</html>
